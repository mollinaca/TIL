# データ構造とアルゴリズム

## 2-01 アルゴリズム

**アルゴリズム**  
何らかの問題を有限の時間でとくための手順  

**変数**
アルゴリズムにおいて、データを格納するための箱。  
データの種類によって、文字列だったり数値だったりする。  
変数（箱）にデータを格納することを、**代入する**という。

**流れ図（フローチャート）**  
アルゴリズムを記号を用いて表したもの。

**疑似言語**
アルゴリズムをプログラムのように記述するための疑似的な言語。

## 2-02 配列

**データの構造**  
コンピュータはメモリ上にあるデータを処理する。たくさんのデータを**どう配置するか**、  
その並べ方を**データ構造**という。  
効率よく処理するためには、適切なデータ構造が必要。

**配列**  
同じデータの要素が集まったデータ構造。配列と要素と添え字。

## 2-03 リスト構造

**リスト構造**  
リストは、データ部とポインタ部で構成される。  
ポインタをたどることによって、データを取り出すことができる。  
ポインタ部には、次のデータや前のデータのアドレスが入っている。  

* 単方向リスト  
  次のデータへのポインタを一つだけもっているリスト構造
* 双方向リスト  
  次のデータへのポインタのほかに、前へのデータのポインタももっているリスト構造
* 環状リスト
  ポインタによって、データが環状に連結されているリスト構造

リスト構造 → ポインタをたどる

## 2-04 キューとスタック

**キュー（Queue)**  
キューは、格納した順序でデータを取り出すことができるデータ構造。  
このような特徴を **FIFO(First-in First-out)** という。  
データをキューに格納することを **エンキュー（enqueue）** 、  
データをキューから取り出すことを **デキュー（dequeue）** という。

キュー → 先に入ったものから先にでる（FIFO)

**スタック（Stack)**  
スタックは、格納した順序とは逆の順序でデータを取り出す構造。  
このような特徴を **LIFO(Last-in First-out)** という。
データをスタックに入れることを **プッシュ（Push)** 、  
データをスタックから取り出すことを **ポップ(pop)** という。

スタック → 後に入ったものから先に出る（LIFO)

## 2-05 木構造

**木構造（ツリー構造）**   
木構造とは、階層の上位から下位に節点をたどることによってデータを取り出すことができるデータ構造。  
節（ノード）、枝（ブランチ）、最上位の節を根（ルート）、最下位の節を葉（リーフ）とよぶ。  
木構造の各節同士には親子関係があり、上位の節を親、下位の節を子、節にぶら下がっている部分を部分木、左側にぶらさがっているものを左部分木、右にぶら下がっているものを右部分木という。

**2分木の種類**  
* 完全2分木  
  根から葉までの深さがすべて等しい2分木です。
  ただし、深さが1だけ深い葉があり、木全体の左から詰められているものも完全2分木とされる。

* 2分探索木
  2分探索木は、各節において「左の子＜親＜右の子」という関係をもった2分木。

* ヒープ木
  各節において「親＜子」または「親＞子」という関係をもった2分探索木。

## 2-06 データの整列

**整列(ソート)**  
ある規則に従ってデータを昇順まだは降順に並べ替えること。

* 記法交換法（隣接交換法、バブルソート）  
  隣り合う要素を比較し、逆順であれば交換して整列を行う手法。
  比較回数は N(N-1)/2 になる。
* 基本選択法（選択ソート）  
  対象集合から最も小さい（大きい）要素を順次取り出して端に置いていく手法。
  比較回数は N(N-1)/2 となる。
* 基本挿入法（挿入ソート）  
  対象集合から要素を順次取り出し、それまでに取り出した要素の集合に順序関係をもつよう挿入して整列を行う手法。挿入しながら交換する。
  比較回数は N(N-1)/2 となる。

**計算量（オーダ）**  
処理するデータ量によって、プログラムの実行時間がどのように変化するかを考えるときに使う概念。  
n個のデータを処理する最大実行時間がCn^2（Cは定数）だった場合、実行時間のオーダはO(n^2)となる。

| 実行時間(例) | オーダ |
|-|-|
| C | 1 |
| 100n | n |
|3n^2+5n+1000| n^2 |

* 順次処理で構成されている部分は、実行時間の最も長い行のオーダが全体のオーダになる  
* 繰り返し処理で構成されている部分は、繰り返されてる部分のオーダに繰り返し数をかけた値のオーダが全体のオーダになる。

基本交換法、基本選択法、基本挿入法のオーダはO(n^2)

**その他のソート**  
* シェルソート(改良挿入法)  
  ある一定間隔おきに取り出した要素からなる部分列をそれぞれ整列し、さらに間隔を詰めて同様の操作を行い、間隔が1になるまで繰り返す  
* クイックソート
  適当な基準値を決めて、それよりも大きな値を集めた区分と小さな値を集めた区分の要素に振り分ける。
  次に、それぞれの区分の中で同様の処理を繰り返して、整列を行う。
* ヒープソート
  未整列の部分を順序木に構成し、そこから最大または最小値を取り出して寄生列の部分に移す。
  この処理を繰り返して未整列部分を縮めて整列を行う方法。

## 2-07 データの探索

配列などを使って、目的のデータを探し出すことを探索という。  

**線形探索法（逐次探索法）**  
配列の先頭から順番に目的のデータを調べていく方法。
ローラー作戦のようにしらみつぶしに探す。  
不規則に配列されている多数のデータの中から、目的のデータを探し出すのに適しているが、時間がかかる。

番兵法：線形探索効率化の手法。対象配列の線形探索を行い、見つからなかったら末尾に対象の数字を足すことで、1回の比較の中で「末尾まで確認したか？」を比較せずに済む。

線形探索の探索回数と計算量は、最大がN回、平均が(N+1)/2となる。O(n)

**2分探索**  
目的のデータと配列の中央のデータを比較し、一致しなければその大小関係から中央のデータを除いた前半、後半のいずれかの範囲に限定する。約半分になった範囲で同様のことを行い、比較を繰り返して探索を行う。1/2に狭めながら探索を行う。

探索回数は、平均探索数Log2N回、最大探索数はLog2N+1回。  
2^k<=N<2^(k+1)

**ハッシュ探索**
キーの関数値によって格納先のアドレスを算出し直接探索する手法。  
格納先のアドレスが衝突することをシノニムという。

ハッシュ探索で探索した場合、ハッシュ値が衝突する確率は無視できるものとした場合、探索回数は1となる。  
ハッシュ値が衝突する確率が最も小さくなるのは、ハッシュ値が一様分布に近似される場合。  

ハッシュ探索の計算量は O(1)
