# データ構造とアルゴリズム

## 2-01 アルゴリズム

**アルゴリズム**  
何らかの問題を有限の時間でとくための手順  

**変数**
アルゴリズムにおいて、データを格納するための箱。  
データの種類によって、文字列だったり数値だったりする。  
変数（箱）にデータを格納することを、**代入する**という。

**流れ図（フローチャート）**  
アルゴリズムを記号を用いて表したもの。

**疑似言語**
アルゴリズムをプログラムのように記述するための疑似的な言語。

## 2-02 配列

**データの構造**  
コンピュータはメモリ上にあるデータを処理する。たくさんのデータを**どう配置するか**、  
その並べ方を**データ構造**という。  
効率よく処理するためには、適切なデータ構造が必要。

**配列**  
同じデータの要素が集まったデータ構造。配列と要素と添え字。

## 2-03 リスト構造

**リスト構造**  
リストは、データ部とポインタ部で構成される。  
ポインタをたどることによって、データを取り出すことができる。  
ポインタ部には、次のデータや前のデータのアドレスが入っている。  

* 単方向リスト  
  次のデータへのポインタを一つだけもっているリスト構造
* 双方向リスト  
  次のデータへのポインタのほかに、前へのデータのポインタももっているリスト構造
* 環状リスト
  ポインタによって、データが環状に連結されているリスト構造

リスト構造 → ポインタをたどる

## 2-04 キューとスタック

**キュー（Queue)**  
キューは、格納した順序でデータを取り出すことができるデータ構造。  
このような特徴を **FIFO(First-in First-out)** という。  
データをキューに格納することを **エンキュー（enqueue）** 、  
データをキューから取り出すことを **デキュー（dequeue）** という。

キュー → 先に入ったものから先にでる（FIFO)

**スタック（Stack)**  
スタックは、格納した順序とは逆の順序でデータを取り出す構造。  
このような特徴を **LIFO(Last-in First-out)** という。
データをスタックに入れることを **プッシュ（Push)** 、  
データをスタックから取り出すことを **ポップ(pop)** という。

スタック → 後に入ったものから先に出る（LIFO)

## 2-05 木構造

**木構造（ツリー構造）**   
木構造とは、階層の上位から下位に節点をたどることによってデータを取り出すことができるデータ構造。  
節（ノード）、枝（ブランチ）、最上位の節を根（ルート）、最下位の節を葉（リーフ）とよぶ。  
木構造の各節同士には親子関係があり、上位の節を親、下位の節を子、節にぶら下がっている部分を部分木、左側にぶらさがっているものを左部分木、右にぶら下がっているものを右部分木という。

**2分木の種類**  
* 完全2分木  
  根から葉までの深さがすべて等しい2分木です。
  ただし、深さが1だけ深い葉があり、木全体の左から詰められているものも完全2分木とされる。

* 2分探索木
  2分探索木は、各節において「左の子＜親＜右の子」という関係をもった2分木。

* ヒープ木
  各節において「親＜子」または「親＞子」という関係をもった2分探索木。


## 2-06 データの整列

## 2-07 データの探索
